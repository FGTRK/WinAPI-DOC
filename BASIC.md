### GUI
Приложение **представлено** своим окном. Стандартный интерфейс окна **упрощает** изучение программ

### Многозадачность
Запуск нескольких программ одновременно
**Вытесняющая многозадачность** -  сама ОС переключает управление программами
**Процесс** - программный код и выделенные под него ресурсы

Окно всегда **принадлежит** потоку. Поток может не владеть окнами

Есть **иерархия** окон - дочерние и родительские

Есть только одно **активное** окно на экране

### Управление памятью
Если объем доступной ОЗУ меньше файла, то ОС может загружать файл **по частям**

Компоновщик связывает код библиотечных функций C/C++ с кодом программы на этапе **компоновки** (статическое связывание), в то время как для функций Windows это связывание откладывается и осуществляется только на этапе **выполнения** программы (динамическое связывание)
При загрузке программы в специальной таблице настраиваются адреса на dll функции

---
**Системный объект Windows** - структура данных в адресном пространстве системы, недоступная приложению напрямую
Объекты в Windows - окна, кисти, палитры (объект **не** в терминах ООП)

Любой объект в Windows **идентифицируется** своим дескриптором (описателем)
**Дескриптор** (handle) — это своего рода ссылка на объект
Дескриптор представлен в виде *идентификатора или структуры*

Все **взаимоотношения** программного кода с объектом осуществляются только через его дескриптор. Система Windows тщательно скрывает свои внутренние секреты и не допускает прямого доступа к внутренним структурам объекта

Процесс **не может** использовать дескрипторы другого процесса

Объект жив пока жив **его дескриптор**

В Windows есть 3 типа объектов:
* Объекты **ядра** - управление процессам
* Объекты **пользователя** - работа с окнами
* Объекты **GDI** - для работы с графикой

Типы данных **определены** через директиву \#define или typedef

---
## Сообщения
Окна получают инфу от пользователей в виде **сообщений**. Также через сообщения взаимодействуют сами окна
**Сообщение** - уведомление о событии, требующее выполнение действий 
Событием мб движение мыши, нажатие на кнопку либо сообщение от самой ОС

Сообщение содержит:
* дескриптор окна, которому **адресовано** сообщение
* **код** сообщения
* доп. инфу, зависящую от кода сообщения

Сообщения от внешних источников (типа клавиатуры) адресуются только **активному** окну
Все сообщения помещаются в *системную очередь сообщений*. Windows берет сообщение из очереди и посылает его в *очередь сообщений потока приложения*, для окна которого оно было адресовано
Для каждого потока приложения создается *очередь сообщений потока приложения*

Событие -> системная очередь сообщений -> очередь сообщений потока приложения

## Оконная процедура
**Оконная процедура** — это «функция обратного вызова», предназначенная для
**обработки** сообщений, адресованных любому окну того «оконного класса», в котором содержится ссылка на данную процедуру

Функция обратного вызова - их вызывает сама **ОС**
Признак: спецификатор CALLBACK. В коде приложения **не будет прямого** вызова такой функции
```c++
LRESULT CALLBACK имя_функ(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
```

* LRESULT - тип возвращаемого значения
* hWnd - дескриптор окна, которому адресовано сообщение
* uMsg - код сообщения
* wParam, lParam - параметры сообщения

Для главного окна имя такой функции **WndProc**
В такой функции есть **switch**
* WM_ - window messages, сообщения к окну
* BM_ - button messages, сообщения от кнопок
* EM_ - edit messages, сообщения от текстовых полей
* LB_ - list messages, сообщения от списков

Можно создать **свои** типы сообщений

## Оконные классы
(Класс **не** в терминах ООП)
Оконный класс это как **тип** для данного окна
**Оконный класс** - структура, определяющая основные хар-ки окна:
* стиль окна
* ресурсы (курсор, меню, кисть для закрашивания фона)
* адрес оконной процедуры, для обработки сообщений

Ссылка на оконный класс передается **CreateWindow** для создания окна

На основе **одного** оконного класса можно создать множество подобных окон
WinAPI  содержит **предопределенные** оконные классы для кнопок, списков, диалоговых окон...

Для **главного** окна создается **свой** оконный класс

## Цикл обработки сообщений
WinMain содержит создание необходимых *окон*, после чего **цикл обработки сообщений** и код для **закрытия** приложения

GetMessage **извлекает** сообщение из очереди сообщений приложения
* Код сообщения WM_QUIT - выход из цикла
* сообщение передается DispatchMessage, которая передает его оконной процедуре

Если в очереди нет сообщений, то функция будет ждать, **остановив** цикл обработки сообщений

---
В Windows есть два типа сообщения для окон
**Синхронные сообщения** - отправитель сообщения дожидается ответа, прежде чем продолжить работу
**Асинхронные сообщения** - отправитель сообщения продолжает работу, не дожидаясь ответа

Синхронные сообщения: 
* создание окна WM_CREATE
* уничтожение окна WM_DESTROY

Асинхронные сообщения: 
* нажатие клавиш WM_KEYDOWN и WM_KEYUP
* перемещение мыши WM_MOUSEMOVE
* щелчок ЛКМ WM_LBUTTONDOWN
* таймер WM_TIMER
* перерисовка клиентской области WM_PAINT
* выход из программы WM_QUIT

**SendMessage**  отправляет синхронное сообщение в очередь событий приложения и **ждет ответа**
**PostMessage** отправляет асинхронное сообщение в очередь событий приложения и **сразу возвращает управление**, не дожидаясь ответа

```c++
SendMessage(hWnd, WM_DESTROY, 0, 0); // уничтожить окно
```

Сначала обрабатываются все синхронные сообщения, затем асинхронные
## Глобальные и статические переменные
При повторном вызове WndProc значения ее локальных переменных от предыдущего вызова **не сохраняются**
Для передачи информации из одного сообщения в другое используются либо **статические** либо **глобальные** переменные


