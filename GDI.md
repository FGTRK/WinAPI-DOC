**Графический интерфейс устройства (GDI)** - обеспечивает графический вывод на принтер, монитор, память

Аппаратная независимость - **приложение** через **GDI** взаимодействует с **драйверами** устройств (gdi32.dll)

---
Для **связи** приложения с GDI используют контекст устройства
**Контекст устройства** - структура, включающая набор графических объектов, их атрибутов, режимов вывода **для отображения** на устройстве

Графические объекты GDI:
* **перо** для рисования линий
* **кисть** для заполнения фона, заливки фигур
* **шрифт** для вывода текста
* **регион** для отсечения областей вывода
* **растровое** изображение

Все они имеют общий тип **HGDIOBJ**

Для рисования на устройстве вывода надо **получить** дескриптор контекста устройства

Использование любого графического объекта предполагает:
1. Create… **Создание** графического объекта
2. SelectObject **Выбрать** объект в контексте устройства, **сохранив** старый
3. **Вызвать** графическую функцию
4. **Вернуть** предшествующий объект контексту устройства
5. DeleteObject **Уничтожить** созданный объект (если не нужен)

Можно получить предопределенный графический объект через **GetStockObject**. Его удалять не надо

Функции GDI извлекают большую часть информации из контекста устройства

### Регионы
Они позволяют **перерисовывать** не все окно, а только необходимую часть

Обновляемый (недействительный) регион - требует обновления после определенных **событий**
Видимый регион - часть окна, которую **видит пользователь**
Регион отсечения - область, где **разрешено** рисование

---
**Получить** ресурс - **Освободить** ресурс

Для обработки сообщения **WM_PAINT** используют:
* BeginPaint - получить контекст устройства. Рисование будет только в недействительных регионах
* Endpaint - освободить контекст устройства

```c++
hdc = GetDC(hWnd); // получить контекст устройства
				   // NULL для всего экрана
int hDCLact = SaveDC(hDc); // сохранить состояние DC

RestoreDC(hDc, hDCLact); // восстановить состояние DC
Release(hWnd, hDc); // осободить DC
```

---
### Контекст в памяти (**совместимый контекст**)
Позволяет выводит изображение **в память**
```c++
memhDc = CreateCompatibleDC(hdc);
```

С ним нужно связать растр (**bitmap**) с нужной высотой и шириной через **SelectObject** или **CreateCompatibleBitmap**

**DeleteDC** - удалить совместимый контекст

Используется для **двойной буферизации**

---
У графических примитивов есть **основные** и **фоновые** пиксели. Основные образуют **очертание** самого примитива
У пунктирных линий пиксели линий - основные, а пиксели между ними - фоновые
**SetBkColor** изменяет **цвет фона** контекста устройства

```c++
SetBkMode(hDc, TRANSPARENT); // прозрачный фон
```
---
### Перо
На уровне драйверов устройств есть **оптимизированные** функции для рисования линий
**Перо** - графический объект для рисования линий, контуров замкнутых фигур

```c++
MoveToEx(hDc, x, y, &p); // задать начало рисования
LineTo(hDc, x, y); // нарисовать линию 
```

**MoveToEx** задает текущую **позицию** пера в контексте устройства
**LineTo** рисует линию от текущей позиции до заданной. При этом текущая позиция **становится** заданной

```c++
POINT pt[5] = {{100, 100}, {200, 100}, {200, 200}, {100, 200}, {100, 100}};
Polyline(hDc, pt, 5); // замкнутая ломанная 
```

Имеет тип **HPEN**
```c++
HPEN hPen; // Объект пера
```

Объект пера, как и другие объекты GDI, использует **ресурсы** ОС, поэтому после его ненадобности его нужно удалить через **DeleteObject**

Предопределенные перья **GetStockObject**:
* **NULL_PEN** - используется для вывода фигур **без контура**
* **DC_PEN** - позволяет **изменять** свой цвет без пересоздания

Хорошим тоном является **сохранение предыдущего** дескриптора и **возврат его** после завершения рисования:
```c++
HPEN hOldPen = (HPEN)SelectObject(hDc, GetStockObject(NULL_PEN)); // сохранение
// рисование
SelectObject(hDc, hOldPen); //возврат
```

**CreatePen** создает перо
```c++
static HPEN hPen = CreatePen(PS_SOLID, // тип обводки
		  5,                 // толщина
		  RGB(255, 200, 100) // цвет
		  );
HPEN hOldPen = (HPEN)SelectObject(hDc, hPen);
DeleteObject(SelectObject(hDc, hOldPen)); // удалить неиспользуемое перо
```
---
### Кисть
**Кисть** — это растр размером m × n пикселов, который при закрашивании области
дублируется в горизонтальном и вертикальном направлении

Имеет тип **HBRUSH**
```c++
HBRUSH hBrush; // Объект кисти
```

Операции **SelectObject** **DeleteObject** с кистью такие же, как и с перьями

Предопределенные кисти **GetStockObject**:
* **NULL_BRUSH** - используется для вывода фигур **без фона**
* **DC_BRUSH** - позволяет **изменять** свой цвет без пересоздания

3 **вида** кистей:
* CreateSolidBrush(RGB(0, 0, 0)) - **сплошная** кисть
* CreateHatchBrush(HS_CROSS, RGB(100, 100, 100))) - **штриховая** кисть
* CreatePatternBrush(hmp) - **растровая** кисть

Растровая кисть принимает дескриптор растрового объекта **bitmap**
```c++
// загрузить растр
HBITMAP hBmp = (HBITMAP)LoadImage(NULL, L"test.bmp", IMAGE_BITMAP,
0, 0, LR_LOADFROMFILE);
// создать растровую кисть
HBRUSH hBrush = CreatePatternBrush(hBmp);
// установить растровую кисть
HBRUSH hOldBrush = (HBRUSH)SelectObject(hDc, hBrush);
// нарисовать прямоугольник
Rectangle(hDc, 0, 0, 1920, 700);
```

### Прямоугольники
Используют структуру **RECT**

```c++
RECT rect;
SetRect(&rect, x_left, y_top, x_right, y_bottom);

// рисует прямоугольник пером и кистью из hDc
Rectangle(hDc, rect.left, rect.top, rect.right, rect.bottom);

//только закрашивает кистью, не трогая границы
FillRect(hDc, &rect, hBrush);
```

---
Обработка сообщения **WM_PAINT**
```c++
RECT clientRect;
case WM_PAINT: // сообщение о перерисовке
	GetClientRect(hWnd, &clientRect); // размеры клиентской области

	PAINTSTRUCT ps;
	HDC hdc; // дескриптор контекста устройства
	hdc = BeginPaint(hWnd, &ps); // получить дескриптор контекста устройства
	//FillRect(hdc, &clientRect, reinterpret_cast<HBRUSH>(GetStockObject(BLACK_BRUSH)));

	HPEN newPen;
	newPen = CreatePen(PS_SOLID, 5, RGB(0, 255, 0)); // создать перо (границы)

	HBRUSH newBrush;
	newBrush = CreateSolidBrush(RGB(123, 213, 44)); // создать кисть (фон)

	HGDIOBJ oldPen, oldBrush;
	oldPen = SelectObject(hdc, newPen); // установить новую, вернуть старую
	oldBrush = SelectObject(hdc, newBrush);

	Rectangle(hdc, clientRect.left + 10, clientRect.top + 10,
		clientRect.right - 10, clientRect.bottom - 10); // нарисовать прямоугольник на устройстве

	SelectObject(hdc, oldPen); // вернуть старый объект
	SelectObject(hdc, oldBrush);

	DeleteObject(newPen); // очистить ресурсы
	DeleteObject(newBrush);

	EndPaint(hWnd, &ps); // освободить контекс устройства
	break;
```

